import Mathlib
import LocalClassFieldTheory.FromMathlib.SpectralNormUnique

/-!
# Krasner's Lemma

In this file, we prove Krasner's lemma. Instead of state and prove the Krasner's lemma directly,
we define predicates `IsKrasnerNormed K L` `IsKrasnerValued K L` for arbitary field extensions
`L / K` with a normed/valued instance on `L` as the abstraction of the conclusion of the
Krasner's lemma. Then we prove the Krasner's lemma holds for every algebraic field extension
`L / K` if `K` is a complete normed/valued field and the norm/valuation
on `L` is compatible with the one on `K`.

## Main definitions

* `IsKrasnerNormed K L` : Given a field extension `L / K` and two elements `x y : L`,
if `x` is separable over `K` and all conjugate roots of `x` lives in `L`,
`y` is integral over `K` and the distance between `x` and `y` is less than the distance between
`x` and any other conjugate root of `x`,
then `x` is in the field generated by `K` and `y`.

* `IsKrasnerValued K L` : The same as `IsKrasnerNormed K L`, but
stated using valuation instead of norm.

## Main results

* `IsKrasnerNormed.of_complete` : If `K` is a complete normed field, such that
the norm of `L` extends the norm on `K`, then `IsKrasner K L` holds for every
algebraic extension `L` over `K`.

* `IsKrasnerValued.of_complete` : The same as `IsKrasnerNormed.of_complete`, but
stated using valuation instead of norm.

## Tags
Krasner's lemma, normed field, valued field

-/

namespace IntermediateField

@[simp]
lemma mem_map {K L L': Type*} [Field K] [Field L] [Field L'] [Algebra K L] [Algebra K L'] {S : IntermediateField K L} {f : L →ₐ[K] L'} {y : L'} : y ∈ S.map f ↔ ∃ x ∈ S, f x = y :=
  Set.mem_image f S y

-- Higher priority to apply before `mem_map`.
@[simp 1100]
lemma mem_map' {K L L': Type*} [Field K] [Field L] [Field L'] [Algebra K L] [Algebra K L'] {S : IntermediateField K L} (f : L →ₐ[K] L') {x : L} : f x ∈ S.map f ↔ x ∈ S :=
  ⟨fun h ↦ let ⟨_, ha⟩ := mem_map.mp h; f.injective ha.2 ▸ ha.1, fun h ↦ mem_map.mpr ⟨x, h, rfl⟩⟩

end IntermediateField

section AlgebraNorm

namespace MulAlgebraNorm

variable {R S : Type*} [SeminormedCommRing R] [Ring S] [Algebra R S]

def toAlgebraNorm (f : MulAlgebraNorm R S) : AlgebraNorm R S := {
  f with
  mul_le' _ _ := (f.map_mul' _ _).le
}

instance : Coe (MulAlgebraNorm R S) (AlgebraNorm R S) := ⟨toAlgebraNorm⟩

@[simp]
lemma coe_AlgebraNorm (f : MulAlgebraNorm R S) : ⇑(f : AlgebraNorm R S) = ⇑f := rfl

end MulAlgebraNorm

namespace NormedAlgebra

def toMulAlgebraNorm (K L : Type*) [NormedField K] [NormedField L]
    [NormedAlgebra K L] : MulAlgebraNorm K L := {
      NormedField.toMulRingNorm L with
      smul' r x := by
        simp only [Algebra.smul_def, AddGroupSeminorm.toFun_eq_coe, MulRingSeminorm.toFun_eq_coe,
          map_mul, mul_eq_mul_right_iff, map_eq_zero]
        exact Or.inl <| norm_algebraMap' L r
    }

@[simp]
lemma toMulAlgebraNorm_apply (K : Type*) {L : Type*} [NormedField K] [NormedField L]
    [NormedAlgebra K L] (x : L) : toMulAlgebraNorm K L x = ‖x‖ := rfl

lemma norm_eq_spectralNorm (K : Type*) {L : Type*} [NontriviallyNormedField K]
    [IsUltrametricDist K] [NormedField L] [NormedAlgebra K L] [Algebra.IsAlgebraic K L]
    [CompleteSpace K] (x : L) : ‖x‖ = spectralNorm K L x := by
  rw [← toMulAlgebraNorm_apply K x, ← spectralAlgNorm_def IsUltrametricDist.isNonarchimedean_norm, ← MulAlgebraNorm.coe_AlgebraNorm]
  congr
  apply spectral_norm_unique'
  exact MulRingNorm.isPowMul (toMulAlgebraNorm K L).toMulRingNorm

end NormedAlgebra

end AlgebraNorm

open IntermediateField Valued

variable (K L : Type*)

section Norm

variable [NormedField L]

class IsKrasnerNormed [Field K] [Algebra K L] : Prop where
  krasner_normed' : ∀ {x y : L}, IsSeparable K x → (minpoly K x).Splits (algebraMap K L) →
    IsIntegral K y → (∀ x' : L, IsConjRoot K x x' →  x ≠ x' → ‖x - y‖ < ‖x - x'‖) →
      x ∈ K⟮y⟯

namespace IsKrasnerNormed

variable {K L} in
theorem krasner_normed [Field K] [Algebra K L]
    [IsKrasnerNormed K L] {x y : L} (hx : (minpoly K x).Separable)
    (sp : (minpoly K x).Splits (algebraMap K L)) (hy : IsIntegral K y)
    (h : (∀ x' : L, IsConjRoot K x x' → x ≠ x' → ‖x - y‖ < ‖x - x'‖)) : x ∈ K⟮y⟯ :=
  IsKrasnerNormed.krasner_normed' hx sp hy h

variable [NontriviallyNormedField K] [CompleteSpace K] [IsUltrametricDist K]
    [NormedAlgebra K L] [Algebra.IsAlgebraic K L]

theorem of_completeSpace_of_normal [Normal K L] : IsKrasnerNormed K L := by
  constructor
  intro x y xsep sp yint kr
  let z := x - y
  haveI := IntermediateField.adjoin.finiteDimensional yint
  letI : NontriviallyNormedField K⟮y⟯ := {
    non_trivial := by
      obtain ⟨k, hk⟩ :=  @NontriviallyNormedField.non_trivial K _
      use algebraMap K K⟮y⟯ k
      simp [hk]
    }
  letI : CompleteSpace K⟮y⟯ := FiniteDimensional.complete K K⟮y⟯
  haveI : IsUltrametricDist L := IsUltrametricDist.of_normedAlgebra K
  haveI : Normal K⟮y⟯ L := Normal.tower_top_of_normal K K⟮y⟯ L
  let y' : K⟮y⟯ := ⟨y, IntermediateField.subset_adjoin K {y} rfl⟩
  have zsep : IsSeparable K⟮y⟯ z := by
    apply Field.isSeparable_sub (IsSeparable.tower_top K⟮y⟯ xsep)
    simpa using isSeparable_algebraMap y'
  suffices z ∈ K⟮y⟯ by simpa [z, y'] using add_mem this y'.2
  by_contra hz
  have : z ∈ K⟮y⟯ ↔ z ∈ (⊥ : Subalgebra K⟮y⟯ L) := by
    rw [Algebra.mem_bot]
    simp
  rw [this.not] at hz
  obtain ⟨z', hne, h1⟩ := (not_mem_iff_exists_ne_and_isConjRoot zsep
      (minpoly_sub_algebraMap_splits y' (IsIntegral.minpoly_splits_tower_top
        xsep.isIntegral sp))).mp hz
  simp only [ne_eq, Subtype.mk.injEq] at hne
  obtain ⟨σ, hσ⟩ := isConjRoot_iff_exists_algEquiv.mp h1
  apply_fun σ.symm at hσ
  simp only [AlgEquiv.symm_apply_apply] at hσ
  have : ‖z - z'‖ < ‖z - z'‖ := by
    calc
      _ ≤ max ‖z‖ ‖z'‖ := by
        simpa only [norm_neg, sub_eq_add_neg] using (IsUltrametricDist.norm_add_le_max z (- z'))
      _ ≤ ‖x - y‖ := by
        simp only [NormedAlgebra.norm_eq_spectralNorm K, hσ, sup_le_iff]
        rw [← AlgEquiv.restrictScalars_apply K, ← spectralNorm_aut_isom (σ.symm.restrictScalars K)]
        simp [z]
      _ < ‖x - (z' + y)‖ := by
        apply kr (z' + y)
        · apply IsConjRoot.of_isScalarTower (L := K⟮y⟯) xsep.isIntegral
          simpa [z, y'] using IsConjRoot.add_algebraMap y' h1
        · simpa [z, sub_eq_iff_eq_add] using hne
      _ = ‖z - z'‖ := by congr 1; ring
  simp only [lt_self_iff_false] at this

instance of_completeSpace : IsKrasnerNormed K L := by
  constructor
  intro x y xsep sp yint kr
  let C := AlgebraicClosure K
  letI : NormedField C := spectralNormToNormedField (K := K) IsUltrametricDist.isNonarchimedean_norm
  letI : NormedAlgebra K C := {
    spectralNormToNormedSpace (K := K) IsUltrametricDist.isNonarchimedean_norm with
    ..
  }
  let iL : L →ₐ[K] C := IsAlgClosed.lift
  letI := iL.toAlgebra
  letI := IsScalarTower.of_algHom iL
  letI : NormedAlgebra L C := {
    norm_smul_le _ _ := by
      apply le_of_eq
      simp only [Algebra.smul_def, norm_mul, mul_eq_mul_right_iff, _root_.norm_eq_zero]
      simp only [NormedAlgebra.norm_eq_spectralNorm K]
      exact Or.inl <| (spectralValue.eq_of_tower _).symm
  }
  letI := IsKrasnerNormed.of_completeSpace_of_normal K C
  have norm_iL : ∀ x, ‖iL x‖ = ‖x‖ := norm_algebraMap' _
  suffices this : iL x ∈ K⟮iL y⟯ by
    simpa [← Set.image_singleton, ← IntermediateField.adjoin_map] using this
  apply IsKrasnerNormed.krasner_normed
  · exact xsep.map.of_dvd <| minpoly.dvd_map_of_isScalarTower' K K C x
  · refine Polynomial.splits_of_splits_of_dvd _
        (Polynomial.map_ne_zero (minpoly.ne_zero xsep.isIntegral)) ?_
        (minpoly.dvd_map_of_isScalarTower' K K C x)
    rw [Polynomial.splits_map_iff]
    exact Polynomial.splits_of_isScalarTower (K := L) C sp
  · exact yint.map iL
  · intros xC' hx' hne
    have : xC' ∈ (minpoly K x).rootSet C := by
      rwa [isConjRoot_iff_mem_minpoly_rootSet (xsep.isIntegral.map _), minpoly.algHom_eq iL iL.injective x] at hx'
    simp only [← Polynomial.image_rootSet sp iL, Set.mem_image] at this
    choose x' hx' hxC' using this
    rw [← isConjRoot_iff_mem_minpoly_rootSet xsep.isIntegral] at hx'
    simpa [← hxC', norm_iL, ← map_sub] using kr x' hx' (fun h ↦ hne (h ▸ hxC'))

end IsKrasnerNormed

end Norm

#min_imports
